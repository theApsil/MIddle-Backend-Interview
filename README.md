# В этом репозитории вы можете посмотреть мой процесс познания и получения оффера на должность Middle Python Backend Dev'a в компанию <a href="agora.ru"> Agora </a>
![img.png](img%2Fimg.png)


# Пройдёмся последовательно по каждому пункту относительно теории и немного практики

![docker.png](img%2Fdocker.png)

| Команда                   | Описание                                                                  |
|--------------------------|---------------------------------------------------------------------------|
| `docker run <имя_образа>`| Запускает контейнер на основе указанного образа.                        |
| `docker build .`         | Собирает Docker образ из Dockerfile в текущей директории.                |
| `docker ps`              | Показывает запущенные контейнеры.                                        |
| `docker images`          | Показывает список сохраненных Docker образов на системе.                 |
| `docker stop <container>`| Останавливает работу контейнера.                                         |
| `docker rm <container>`  | Удаляет контейнер.                                                       |
| `docker rmi <image>`     | Удаляет Docker образ.                                                     |
| `docker pull <image>`    | Загружает Docker образ из репозитория.                                    |
| `docker exec -it <container> <command>` | Запускает команду внутри контейнера.                            |
| `docker-compose up`      | Запускает приложение согласно настройкам в файле docker-compose.yml.     |
| `docker logs <container>`                | Показывает логи указанного контейнера.                                        |
| `docker logs -f <container>`             | Отображает логи указанного контейнера в реальном времени (следит за логами).  |
| `docker logs --tail <number> <container>`| Показывает последние <number> строк логов указанного контейнера.             |
| `docker logs --since <time> <container>` | Показывает логи контейнера, начиная с указанного времени (например, 1h ago).  |
| `docker logs --until <time> <container>` | Показывает логи контейнера до указанного времени.                             |

![git.png](img%2Fgit.png) 
# (+ разрешение конфликтов)

| Команда                                     | Описание                                                                      |
|---------------------------------------------|-------------------------------------------------------------------------------|
| `git init`                                  | Инициализирует новый репозиторий Git в текущей директории.                   |
| `git clone <URL>`                           | Клонирует существующий репозиторий из указанного URL.                        |
| `git add <file>`                            | Добавляет изменения файла в индекс (staging area) для последующего коммита.  |
| `git commit -m "<message>"`                 | Создает коммит с зафиксированными изменениями и сообщением о коммите.        |
| `git status`                                | Показывает состояние рабочего каталога и индекса.                            |
| `git branch`                                | Показывает список локальных веток и текущую ветку.                           |
| `git checkout <branch>`                     | Переключается на указанную ветку.                                           |
| `git merge <branch>`                        | Объединяет указанную ветку в текущую ветку.                                  |
| `git pull`                                  | Получает изменения из удаленного репозитория и объединяет их с текущей веткой.|
| `git push`                                  | Отправляет локальные коммиты в удаленный репозиторий.                       |
| `git diff`                                  | Показывает различия между рабочим каталогом и индексом.                     |
| `git log`                                   | Показывает историю коммитов.                                                 |
| `git reset <file>`                          | Отменяет изменения файла в индексе.                                          |
| `git reset --hard HEAD`                     | Сбрасывает все изменения в рабочем каталоге и индексе до последнего коммита.|
| `git checkout -- <file>`                    | Восстанавливает файл до его состояния на момент последнего коммита.         |
| `git stash`                                 | Сохраняет текущие изменения во временном хранилище.                          |
| `git stash apply`                           | Применяет последние изменения из временного хранилища к текущему состоянию.  |
| `git stash pop`                             | Применяет и удаляет последние изменения из временного хранилища.             |
| `git rebase <branch>`                       | Перебазирует текущую ветку на указанную ветку.                              |
| `git mergetool`                             | Запускает внешнее приложение для разрешения конфликтов слияния.              |

Команды `git mergetool` и `git mergetool --tool-help` могут быть полезны при разрешении конфликтов слияния, так как они позволяют запускать внешние инструменты для удобного разрешения конфликтов.

### Конфликты слияния в Git
Системы контроля версий предназначены для управления дополнениями, вносимыми в проект множеством распределенных авторов (обычно разработчиков). Иногда один и тот же контент могут редактировать сразу несколько разработчиков. Если разработчик A попытается изменить код, который редактирует разработчик B, может произойти конфликт. Для предотвращения конфликтов разработчики работают в отдельных изолированных ветках. Основная задача команды git merge заключается в слиянии отдельных веток и разрешении любых конфликтующих правок.

### Общие сведения о конфликтах слияния
Обычно конфликты возникают, когда два человека изменяют одни и те же строки в файле или один разработчик удаляет файл, который в это время изменяет другой разработчик. В таких случаях Git не может автоматически определить, какое изменение является правильным. Конфликты затрагивают только того разработчика, который выполняет слияние, остальная часть команды о конфликте не знает. Git помечает файл как конфликтующий и останавливает процесс слияния. В этом случае ответственность за разрешение конфликта несут разработчики.

### Git прерывает работу в самом начале слияния
Выполнение команды слияния прерывается в самом начале, если Git обнаруживает изменения в рабочем каталоге или разделе проиндексированных файлов текущего проекта. Git не может выполнить слияние, поскольку иначе эти ожидающие изменения будут перезаписаны новыми коммитами. Такое случается из-за конфликтов не с другими разработчиками, а с ожидающими локальными изменениями. Локальное состояние необходимо стабилизировать с помощью команд `git stash`, `git checkout`, `git commit` или `git reset`. Если команда слияния прерывается в самом начале, выдается следующее сообщение об ошибке:
``` git
error: Entry '<fileName>' not uptodate. Cannot merge. (Changes in working directory)
```

### Git прерывает работу во время слияния
Сбой В ПРОЦЕССЕ слияния говорит о наличии конфликта между текущей локальной веткой и веткой, с которой выполняется слияние. Это свидетельствует о конфликте с кодом другого разработчика. Git сделает все возможное, чтобы объединить файлы, но оставит конфликтующие участки, чтобы вы разрешили их вручную. При сбое во время выполнения слияния выдается следующее сообщение об ошибке:
```
error: Entry '<fileName>' would be overwritten by merge. Cannot merge. (Changes in staging area)
```

### Создание конфликта слияния
Чтобы лучше разобраться в конфликтах слияния, в смоделируем конфликт для дальнейшего изучения и разрешения. Для запуска моделируемого примера будет использоваться интерфейс Git c Unix-подобной командной строкой.
```UNIX
$ mkdir git-merge-test
$ cd git-merge-test
$ git init .
$ echo "this is some content to mess with" > merge.txt
$ git add merge.txt
$ git commit -am"we are commiting the inital content"
[main (root-commit) d48e74c] we are commiting the inital content
1 file changed, 1 insertion(+)
create mode 100644 merge.txt
```

С помощью приведенной в этом примере последовательности команд выполняются следующие действия.

* Создается новый каталог с именем git-merge-test, выполняется переход в этот каталог и инициализация его как нового репозитория Git.
* Создается новый текстовый файл merge.txt с некоторым содержимым.
* В репозиторий добавляется файл merge.txt и выполняется коммит.

Теперь у нас есть новый репозиторий с одной веткой main и непустым файлом merge.txt. Далее создадим новую ветку, которая будет использоваться как конфликтующая при слиянии.

```UNIX
$ git checkout -b new_branch_to_merge_later
$ echo "totally different content to merge later" > merge.txt
$ git commit -am"edited the content of merge.txt to cause a conflict"
[new_branch_to_merge_later 6282319] edited the content of merge.txt to cause a conflict
1 file changed, 1 insertion(+), 1 deletion(-)
```

Представленная выше последовательность команд выполняет следующие действия.

* Создает новую ветку с именем new_branch_to_merge_later и выполняет переход в нее.
* Перезаписывает содержимое файла merge.txt.
* Выполняет коммит нового содержимого.

В этой новой ветке new_branch_to_merge_later мы создали коммит, который переопределил содержимое файла merge.txt.

```UNIX
git checkout main
Switched to branch 'main'
echo "content to append" >> merge.txt
git commit -am"appended content to merge.txt"
[main 24fbe3c] appended content to merge.tx
1 file changed, 1 insertion(+)
```
Эта последовательность команд выполняет переключение на ветку main, добавляет содержимое в файл merge.txt и делает коммит. После этого в нашем экспериментальном репозитории находятся два новых коммита, первый — в ветке main, а второй — в ветке new_branch_to_merge_later. Теперь запустим команду git merge new_branch_to_merge_later и посмотрим, что из этого выйдет!

```UNIX
$ git merge new_branch_to_merge_later
Auto-merging merge.txt
CONFLICT (content): Merge conflict in merge.txt
Automatic merge failed; fix conflicts and then commit the result.
```
БАХ! 💥 Возник конфликт. Хорошо, что система Git сообщил нам об этом.

## Команды Git, с помощью которых можно разрешить конфликты слияния
### Общие инструменты
`git status`

Команда status часто используется во время работы с Git и помогает идентифицировать конфликтующие во время слияния файлы.

`git log --merge`

При передаче аргумента --merge для команды git log будет создан журнал со списком конфликтов коммитов между ветками, для которых выполняется слияние.

`git diff`

Команда diff помогает найти различия между состояниями репозитория/файлов. Она полезна для выявления и предупреждения конфликтов слияния.

### Инструменты для случаев, когда Git прерывает работу в самом начале слияния
`git checkout`

Команда checkout может использоваться для отмены изменений в файлах или для изменения веток.

`git reset --mixed`

Команда reset может использоваться для отмены изменений в рабочем каталоге или в разделе проиндексированных файлов.

### Инструменты для случаев, когда конфликты Git возникают во время слияния
`git merge --abort`

При выполнении команды git merge с опцией --abort процесс слияния будет прерван, а ветка вернется к состоянию, в котором она находилась до начала слияния.

`git reset`

Команду git reset можно использовать для разрешения конфликтов, возникающих во время выполнения слияния, чтобы восстановить заведомо удовлетворительное состояние конфликтующих файлов.

![Python_logo_and_wordmark.svg](img%2FPython_logo_and_wordmark.svg)

## Типы данных (mutable и immutable)
1. **Mutable (изменяемый)**: Объекты, значения которых могут быть изменены после создания, считаются изменяемыми. Это означает, что после создания такого объекта его состояние может быть изменено без создания нового объекта с новым значением. Например, списки (list) в Python являются изменяемыми объектами: вы можете добавлять, удалять или изменять элементы списка без создания нового списка.
2. **Immutable (неизменяемый)**: Наоборот, объекты, значения которых не могут быть изменены после создания, считаются неизменяемыми. Это означает, что после создания такого объекта его значение не может быть изменено, и любые операции, направленные на изменение этого значения, создадут новый объект с новым значением. Например, в Python строки (str) являются неизменяемыми объектами: вы не можете изменить символ в строке, но можете создать новую строку с измененным значением.

В качестве самопроверки попробуйте ответить на вопрос:

Что выведет данный код и почему (имеется ввиду разные или одинаковые IDшники)?
```python
a = 'abc'
print(id(a))
a = 'aba'
print(id(a))
```
<details>
<summary> Ответик </summary>

Строка - immutable (т.е. неизменяемый тип данных, мы с вами об этом говорили), даже если учесть то, что имя переменной одно и то же, то при повторном определении значения переменной у нас произойдёт порождение нового объекта (да-да, питон грешен насиранием в оперативку)
</details>

| Mutable                     | Immutable                                                                 |
|-----------------------------|---------------------------------------------------------------------------|
| `lists`                     | `numbers`                                                                 |
| `dictionaries`              | `strings`                                                                 |
| `sets`                      | `tuples`                                                                   |

### Mixins

Это способ повторного использования кода путем комбинирования функциональности из нескольких классов. Они представляют собой специальные классы, которые содержат методы, предназначенные для добавления поведения к другим классам без необходимости множественного наследования.

Существует несколько основных характеристик Миксинов:
1. **Композиционный подход**: Mixins используются для добавления функциональности к существующим классам путем композиции, а не наследования.
2. **Несамостоятельные классы**: Mixins обычно не представляют собой полноценные самостоятельные классы и не предназначены для создания экземпляров.
3. **Использование с множественным наследованием**: Mixins используются в ситуациях, когда необходимо добавить функциональность к классам, которые уже наследуют от других классов.

Пример использования Mixin:
```python
class JSONMixin:
    def to_json(self):
        import json
        return json.dumps(self.__dict__)

class Person:
    def __init__(self, name, age):
        self.name = name
        self.age = age

class Employee(Person, JSONMixin):
    def __init__(self, name, age, salary):
        super().__init__(name, age)
        self.salary = salary

emp = Employee("John", 30, 50000)

print(emp.to_json())
```
В этом примере `JSONMixin` содержит метод `to_json()`, который преобразует атрибуты объекта в строку _JSON_. Класс `Employee` наследует от класса `Person` и использует `JSONMixin`, чтобы получить метод `to_json()` для сериализации экземпляров класса в формат JSON.

### P.S. Что такое композиция?
Концепция в ООП, когда один объект содержит другой в качестве составной части

Например:
```python
class Engine:
    def start(self):
        print("Engine started")

class Car:
    def __init__(self):
        self.engine = Engine()

    def start(self):
        print("Car started")
        self.engine.start()

my_car = Car()
my_car.start()
```
В этом примере класс `Car` содержит объект `Engine` в качестве своего атрибута. Это демонстрирует отношение композиции, где один объект (Car) содержит другой объект (Engine) в качестве своей составной части. Когда вызывается метод `start()` объекта `Car`, он также вызывает метод `start()` объекта `Engine`, что демонстрирует совместную работу компонентов в рамках композиции.

![OOP.png](img%2FOOP.png)